# 예외 자동 전송 어노테이션 라이브러리 구조 설계_최현호

## 작성일
2025-07-24

## 컨텍스트

### 배경  
애플리케이션에서 특정 클래스나 메서드에서 에러가 발생할 때 자동으로 정보를 수집하여 외부 서버로 전송하는 기능이 필요합니다.  
이를 위해 커스텀 Java 어노테이션을 도입하고자 합니다. 이 어노테이션을 클래스 또는 메서드에 달면 다음과 같은 동작을 하도록 설계합니다:  
1. 에러 발생 시 자동 전송: 어노테이션이 붙은 클래스나 메서드에서 에러(Exception)가 발생하면, 해당 클래스/메서드 이름과 에러 발생 위치(라인 번호 등)를 식별하여 즉시 다른 서버로 HTTPS 요청을 통해 전송합니다 (예: 로그 수집 서버).  
2. 호출자 정보 전송: 어노테이션이 붙은 메서드/클래스에서 에러가 발생하면, 그 메서드나 클래스를 호출한 상위 메서드의 정보를 함께 수집하여 전송합니다. (즉, 직접적인 호출자의 이름과 위치를 추가로 전송)  
3. 전후관계 호출 흐름 정보: 에러 발생 시 해당 지점 전후로 호출된 메서드나 행위의 흐름 정보를 최대한 수집합니다. 구체적으로, 에러가 일어난 현재 지점 이전에 호출된 메서드들의 목록(스택 추적)과, 가능하다면 이후에 호출될 예정이었던 메서드나 작업에 대한 정보도 취합하여 전송하려 합니다. 이를 통해 오류 발생 시점의 전체 맥락을 파악하고자 합니다.  
  
위 전송 대상 서버의 주소나 인증 정보 등은 외부 설정 파일 (properties)을 통해 지정하여, 어노테이션 동작 시 해당 설정을 참고해 전송하도록 할 예정입니다. Spring 프레임워크 환경에서만 사용할 계획이며, Kafka나 RabbitMQ 등의 메시지 브로커 연동은 고려하지 않습니다 (전송받은 서버 쪽에서 별도 처리 예정). 오직 HTTPS API 호출 방식으로만 데이터를 보낼 것입니다.

### 요구사항 및 문제점

- 런타임 에러 가로채기: 어노테이션이 적용된 지점에서 예외가 발생하면 이를 런타임에 탐지하여 필요한 정보를 추출해야 합니다. Java의 리플렉션(Reflection)이나 프록시, 또는 AOP 등의 기법을 이용해 예외 발생을 가로채는 메커니즘이 필요합니다.
- 호출 관계 추적: 에러가 발생한 메서드 자체의 정보 뿐만 아니라 호출한 메서드(caller)와 호출된 메서드들의 연쇄를 알아내야 합니다. Java에서 스택 트레이스를 이용하면 현재까지의 호출 스택을 얻을 수 있으므로 이전 호출 흐름은 비교적 쉽게 확보 가능합니다. 그러나 향후 호출 예정이었던 메서드들(에러가 없었다면 이어서 실행되었을 코드)은 실행되지 않았기 때문에, 순수 런타임 정보로는 직접 알아내기가 어렵습니다. 이 부분은 설계 시 현실적인 한계를 고려해야 합니다.
- 성능 및 안정성: 에러 로깅/전송 기능은 비즈니스 로직에 부수적인 크로스컷팅 관심사입니다. 본 기능이 애플리케이션의 성능이나 흐름을 크게 방해하지 않도록 해야 하며, 예외 상황에서도 추가적인 예외나 무한루프 등이 발생하지 않도록 안전하게 구현해야 합니다. 특히 외부로 데이터를 전송하는 과정에서 네트워크 지연이나 오류가 있더라도 원 애플리케이션의 동작에 치명적 영향을 주지 않도록 비동기 처리나 예외 처리 전략이 필요합니다.

## 대안

아래는 개발 요구사항을 만족하는 모든 대안을 작성하였습니다.  
대안에 대한 결정 사항은 하기의 "결정" 목차에서 확인하실 수 있습니다.  

어노테이션을 활용한 에러 전송 기능을 구현하기 위해 고려한 두 가지 접근 방식은 리플렉션 기반 수동 구현과 AOP(Aspect Oriented Programming)를 활용한 구현입니다:
1) **리플렉션 기반 수동 구현:**  
어노테이션이 붙은 메서드 호출을 프록시나 동적 프록시로 감싸거나, 혹은 각 메서드에 직접 try-catch를 넣어 예외를 포착하고 리플렉션으로 정보를 추출하는 방법입니다.  
이 접근에서는 Thread.currentThread().getStackTrace()나 Throwable 객체의 스택 트레이스를 분석하여 호출자 정보 및 라인 번호 등을 얻을 수 있습니다.  
그러나 순수 리플렉션/프록시 방식을 사용할 경우 예외 전파 시 문제점이 있습니다. 예를 들어 JDK 동적 프록시를 이용해 메서드를 가로챌 경우, 발생한 예외가 UndeclaredThrowableException 등으로 래핑(wrap)되어 호출자에 전달되는 문제가 보고되었습니다.  
실제 사례에 따르면, Spring AOP를 사용하지 않고 수동 프록시로 구현한 시스템에서 예외가 원래 호출자에서 catch되지 못하고 UndeclaredThrowableException으로 바뀌어 전달되는 현상이 나타났습니다.  
이러한 래핑은 특히 체크드 예외가 인터페이스에 선언되지 않은 경우 발생하며, 상위 로직의 예외 처리 흐름을 교란시킬 수 있습니다.  
수동 구현으로 이를 모두 처리하려면 예외 언래핑 등의 추가 코드가 필요하고 구현이 복잡해질 수 있습니다.
2) Spring AOP 기반 구현:  
Spring 프레임워크의 AOP를 활용하면 어노테이션을 손쉽게 포인트컷(Pointcut)으로 설정하고, 예외 발생 시 어드바이스(Advice)에서 필요한 처리를 수행할 수 있습니다.  
예를 들어 @AfterThrowing 어드바이스를 사용하면 특정 조건(여기서는 커스텀 어노테이션이 붙은 메서드 실행)에서 예외가 던져진 후에 자동으로 특정 로직을 실행할 수 있습니다.  
Spring AOP는 내부적으로 JDK 동적 프록시 또는 CGLIB를 사용하지만, Spring이 예외 처리를 투명하게 처리해주므로 개발자가 직접 리플렉션 호출을 다루는 것보다 예외 래핑 등의 문제가 적고 구현이 단순합니다.  
또한 AOP를 사용하면 애플리케이션의 비즈니스 로직과 로그/전송 로직을 분리하여 관심사 분리를 달성하고, 어노테이션만으로 쉽게 해당 기능을 토글할 수 있다는 장점이 있습니다.  

아래는 대안들을 정리한 표입니다.

| 방식                                          | Spring 필요 여부   | 장점                        | 단점                                     |
| ------------------------------------------- | -------------- | ------------------------- | -------------------------------------- |
| **Spring AOP**                              | ❌ (Spring 필요)  | 구현 간결, 선언적 처리             | Spring 종속적, 라이브러리화 어려움                 |
| **JDK 동적 프록시 / CGLIB**                      | ✅ (Java만으로 가능) | Spring 없이 프록시로 메서드 감싸기 가능 | 단, 인터페이스 기반이거나 CGLIB 의존성 필요, 예외 처리 어려움 |
| **Bytecode 조작 (ASM, ByteBuddy, Javassist)** | ✅              | 완전히 프레임워크 독립적, 강력한 기능     | 복잡도 높음, 유지보수 부담                        |
| **AspectJ 컴파일 타임 AOP**                      | ✅              | 강력한 기능, Java 독립 가능        | 설정 복잡, weaving 필요                      |
| **직접 try-catch + 리플렉션**                     | ✅              | 구현 쉬움, 프레임워크 독립           | 반복 코드 많음, 실수 가능                        |

위 대안 중에서 예외 이후 흐름 추정이 가능해야 합니다.  
이를 분석한 대안들을 정리한 표를 첨부합니다.  

### 런타임에 가능한 "예외 이후 흐름" 추정 방식 정리

| 방식                     | 설명                       | 정확도  | 구현 난이도 |
| ---------------------- | ------------------------ | ---- | ------ |
| **1. 소스코드 라인 기반 추론**   | 스택 트레이스 + 소스코드 분석        | ⭐⭐⭐  | 중      |
| **2. 바이트코드 흐름 분석**     | Bytecode에서 이후 invoke 추론  | ⭐⭐⭐⭐ | 매우 높음  |
| **3. TraceContext 기록** | ThreadLocal에 흐름 이름 저장    | ⭐⭐   | 낮음     |
| **4. 개발자 정의 시나리오**     | “A → B → C” 흐름을 명시적으로 정의 | ⭐⭐⭐  | 낮음     |


## 결정
사용자 측에서 사용 환경을 자유롭게 할 수 있도록 하기 위함을 고려하여, 라이브러리 형태로 배포해야하므로 Spring AOP를 사용해서 개발 할 수 없습니다.  
구현 난이도가 높지만 이후 실행될 메서드를 간단히라도 추론하기 위해서는 ByteCode 흐름 분석 기반 개발이 필요합니다.

운영 서버에서 발생하는 예외의 근본 원인을 파악하기 위해, 단순히 스택 트레이스뿐만 아니라 예외 발생 지점 이후 예정된 흐름도 함께 전송하는 기능이 필요합니다.  
기존에 제안된 소스코드 라인 기반 분석은 .java 파일 접근이 필요하기 때문에, JAR/WAR 배포 환경에서는 사용이 불가능합니다.  

이에 따라, .class 파일만으로 분석 가능한 Bytecode 기반의 이후 흐름 추정 기능을 도입하고자 합니다.  
이 기능은 @ErrorMonitor 어노테이션을 통해 활성화되며, 전역 설정을 통해도 동작 여부를 제어할 수 있습니다.  

### 설계 요소

#### 어노테이션 선언 예시
```java
@ErrorMonitor(
    severity = Severity.WARN,
    comment = "개발자가 작성한 코멘트",
    enableFuturePrediction = true  // 이 옵션이 true일 경우, bytecode 기반 흐름 예측 수행
)
public void process() { ... }
```

- severity : error, warn, info로 구분

#### 설정 파일 예시(error-monitor.properties)
```properties
error.monitor.enabled=true
error.monitor.server-url=https://errors.example.com/report
error.monitor.future-calls.enabled=true         # 전역 설정
error.monitor.future-calls.max-depth=5          # 최대 분석할 INVOKE 수
error.monitor.apikey=ABC123
```

### Bytecode 기반 흐름 예측
- 예외 발생 시점에 메서드 이름, 클래스 이름, 라인 번호를 기준으로 .class 파일을 ByteBuddy로 분석
- INVOKE* 바이트코드를 순회하여 예외 발생 지점 이후의 호출 메서드들을 추출
- 설정된 최대 depth 만큼 이후 호출 후보를 수집
- "futureCalls" 필드로 전송 Payload에 포함

### JSON 전송 예시
```json
{
  "class": "com.example.service.UserService",
  "method": "process",
  "line": 45,
  "message": "java.lang.NullPointerException",
  "severity": "WARN",
  "futureCalls": [
    "step3()",
    "audit()"
  ]
}
```

### 구현 노트

#### 주요 클래스 설계
| 클래스                          | 설명                                    |
| ---------------------------- | ------------------------------------- |
| `@ErrorMonitor`              | `enableFuturePrediction` 옵션 포함        |
| `ErrorMonitorHandler`        | 예외 감지 및 Bytecode 분석기 연동               |
| `BytecodeFutureCallAnalyzer` | ByteBuddy 기반 바이트코드 순회 분석기             |
| `ErrorMonitorConfig`         | 전역 설정 로딩 (환경변수 + `.properties`)       |
| `ErrorPayload`               | JSON 직렬화용 DTO 객체, `futureCalls` 필드 포함 |

#### 분석 흐름
```plaintext
[예외 발생]
   ↓
[스택트레이스 → 클래스명 + 라인번호 추출]
   ↓
[BytecodeFutureCallAnalyzer.analyze(class, method, line)]
   ↓
[다음 INVOKE* 추출 → "futureCalls"]
   ↓
[에러 전송 (HttpErrorReporter)]
```

#### 설정 우선 순위
1. 어노테이션 옵션 (@ErrorMonitor.enableFuturePrediction)        ← 메서드/클래스 단위
2. 전역 설정 (error.monitor.future-calls.enabled)                  ← 기본값
3. 미설정 시 기본값: false

#### 작업 리스트
- 어노테이션에 enableFuturePrediction 추가
- BytecodeFutureCallAnalyzer 구현
- ErrorPayload 모델에 futureCalls 필드 추가
- 프로퍼티 설정 및 파싱 처리
- 운영/테스트 환경 분리 대응 (predictFuture: false 시 no-op)
- 분석 실패 시 fallback 로그 및 전송 생략 처리

## 결과

✅ 장점
- 운영 서버에서도 소스 없이 이후 흐름 추정 가능
- .class 파일만 존재하면 분석 가능
- 설정/어노테이션 옵션으로 사용 여부 제어 가능
- 실패 시 graceful fallback 처리 → 시스템 영향 없음

⚠️ 단점
- 정확도 100% 보장 불가 (조건문/루프 분기 등은 고려 어려움)
- 바이트코드 파싱 성능 고려 필요 (단일 예외 분석 시만 수행하여 영향 최소화)
- LineNumberTable이 컴파일 옵션으로 누락된 경우, 정확한 분석 어려움


## 담당자
- 작성자 : 최현호
- 검토자 : 서예진